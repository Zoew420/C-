上官越个人报告
====
***
分工任务
----
我们的项目包括了三次迭代：

第一轮：NS方程的求解器（模拟空气流动的效果）

第二轮：Model层碰撞逻辑的优化

第三轮：Model层的计算并行化 

设计思路
----

第一轮：NS方程的求解器（模拟空气流动的效果）

  我们的项目实现的效果是物理仿真的粒子运动，其影响因子有外部温度，粒子碰撞，和气压影响。本轮我主要负责的是气压影响，通过查阅文献和他人代码，将原理移植到项目之中。我们参考的代码为无边界的自由扩散情况，改动其setboundary函数，使其对边界情况做出应答即可。

第二轮：Model层碰撞逻辑的优化

  在第一轮迭代时，碰撞逻辑为较为简单的交换速度，有一定的能量损失，在物理上不够严谨。
  
  在第一轮迭代时，检测碰撞为从终点到起点的检测，因此粒子可能通过薄物体。
  
  在本轮中对这两点进行了修改，
  
  首先，将碰撞检测改为了前向进行；
  
  第二，采取二维碰撞物理公式，可将其分为x轴，y轴两个维度进行分解，公式为：
  
    v1x1 = 1.0f * (m1 * v1x0 + m2 * v2x0 + K_COLLISION_RESTITUTION * m2 * (v2x0 - v1x0)) / (m1 + m2);
    
    v1y1 = 1.0f * (m1 * v1y0 + m2 * v2y0 + K_COLLISION_RESTITUTION * m2 * (v2y0 - v1y0)) / (m1 + m2);
    
    v2x1 = 1.0f * (m1 * v1x0 + m2 * v2x0 + K_COLLISION_RESTITUTION * m1 * (v1x0 - v2x0)) / (m1 + m2);
    
    v2y1 = 1.0f * (m1 * v1y0 + m2 * v2y0 + K_COLLISION_RESTITUTION * m1 * (v1y0 - v2y0)) / (m1 + m2);
    
  K_COLLISION_RESTITUTION为弹性系数，为表示物体变形恢复能力的参数。

第三轮：Model层的计算并行化

  Model层与view层互动后，会对粒子的位置和状态进行update。在update函数中，计算密集的函数主要有：compute_heat()函数，compute_vel()函数，compute_air_flow()函数，compute_position()函数等。发现,compute_heat()函数，compute_vel()函数，compute_air_flow()函数为可并行函数，互相之间没有时间顺序影响。

  于是定义parallel类，将该部分转换为并行的多线程计算，使帧率得到提高。

个人心得
----

1.	通过本门课程，跟进了一个小型项目从诞生到完结的全部过程，学习了项目开放中的基础方法：git，持续集成等等

2.	学习到了MVVM在c++编程中的应用，了解到了一种主流高效的分工方式的运作机理

3.	加深了对c++的理解和使用能力

4.	增加了开发项目的经验

对课程的改进意见
----

1.	通过本课程我学习到了一个高效c++项目搭建的流程，我认为本门课程可以加入更多的实例代码和开源项目来加深这一个过程，也许会有更为直观的收获。

2. 	对于c++工具的一些高效工具和常用手段仍然不够熟悉，希望能在课程中有一个简略的介绍，不仅仅讲c++的语言特性，也能提及到其的具体表现形式和优越性。
